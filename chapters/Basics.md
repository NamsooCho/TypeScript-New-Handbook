# TypeScript Basics

__toc__

자바스크립트에서 모든 그리고 각각의 값은 일련의 행동들을 갖고 있다. 유저는 다른 동작을 실행하여 이러한 행동들을 관찰할 수 있다.
이 말은 추상적으로 들릴 수 있어서 즉각적인 예를 들자면, `foo` 라는 이름의 변수에 대하여 다음의 동작들을 고려해 보자.

```js
// 프로퍼티 'toLowerCase'
// 를 'foo' 에 대하여 접근하고 호출하는 경우
foo.toLowerCase();

// 'foo' 자체를 호출하는 경우
foo();
```

위의 코드를 상세히 들여다 보면, 첫 번째 실행문 라인은 `toLowerCase` 라는 이름의 프로퍼티를 접근하여 호출하는 것이다.
두번째 것은 `foo` 를 직접적으로 호출하려고 시도하는 것이다.

그러나 우리가 `foo` 의 값이 무언지 모른다고 가정한다면 - 그리고 이런 경우는 매우 흔한 일이다 - 우리는 이러한 코드를 실행한 결과가 무엇이 될지 신뢰성 있게 말할 수 없게 된다.
각각의 동작의 행동은 맨처음 변수에 할당된 값에 따라서 완전히 달라진다.
`foo`가 호출가능 한가?
`toLowerCase` 라는 프로퍼티가 설정되어 있는가?
만약 프로퍼터가 있다면 호출은 가능한 것인가?
만약 이러한 모든 조건이 만족하여 모두 호출이 가능하다면 호출의 결과 값은 무엇이 될 것인가?
이러한 질문들에 대한 답은 보통 우리가 자바스크립트를 사용하여 프로그래밍 할때 늘 머리속에 담고 있는 것이다.
또한 이러한 모든 상세한 조건들이 모두 맞기를 바라면서 말이다.

`foo`가 다음과 같이 정의되어 있다고 한다면

```js
let foo = "Hello World!";
```

아마도 당신이 추측할 수 있듯이, `foo.toLowerCase()` 를 실행한 경우, 소문자로 변환된 동일한 내용의 문자열을 얻게 될 것이다.

그렇다면 두번째 문장을 실행한 결과는 어떠할까?
당신이 자바스크립트에 익숙하다면, 다음의 예외가 발생하면서 실패할 것을 알 것이다.

```txt
TypeError: foo is not a function
```

만약 우리가 이와 같은 실수들을 피할 수 있다면 그것은 매우 좋은일 일 것이다.
우리의 코드를 실행할 때, 자바스크립트 런타임은 값의 타압을 알아내어서 어떤 행동을 할 것인지 선택한다 - 어떤 종류의 행동들과 능력들을 그 값이 가지고 있는지 알아낸다.
`TypeError`가 암시하는 것은 이러한 알아내는 과정의 결과이다 - 자바스크립트 런타임은 스트링 `"Hello World"` 는 함수로서 호출될 수 없다고 말하고 있다.

몇몇 값들은, `string` 과 `number` 같은 기본 타입 값들은, 런타임에 `typeof` 연산자를 사용하여 그 타입을 알아낼 수 있다.
그러나 함수와 같은 다른 것들은 런타임에 그 타입을 알수 있는 방법이 없다.
예를 들어, 다음의 함수를 고려해 보자.

```js
function fn(x) {
    return x.flip();
}
```

우리는 이 함수의 코드를 읽어보고 나서, 이 함수는 `flip` 프로퍼티를 가진 객체에 대해서만 동작할 것이라는 것을 *관찰*할 수 있다. 그러나 자바스크립트는 이러한 정보를 코드가 실행하는 동안 우리한 체크할 수 있도록 밖으로 드러내지 않는다.
순수 자바스크립트에서 이 함수가 특정 객체에 동작한다는 것을 확인 할 방법은 함수를 호출하고 그 결과를 관찰하는 방법 뿐이다.
이러한 종류의 행동은 코드가 실행되기 전에 그 결과를 예측하기에 어렵게 만든다. 이 말의 의미는 코드를 작성할 당시에 이 코드의 실행결과를 알기가 어렵다는 것이다.

여기에서 볼 수 있듯이, *type* 이라는 개념은 특정 함수에 파라메터를 던질때 어떤 값이 옳고, 어떤 값이 옳지 않은지 기술해 준다.
자바스크립트는 진정한 *동적타입* 이다 - 코드를 실행하고 무슨 일이 일어나는지 보는 벙삭이다.

이와 달리 *정적타입* 시스템은 코드가 실행되기 *전에* 무슨일이 일어날지 예측이 가능하게 해준다.

## Static type-checking

다시 뒤로 돌아가 `string`에 대하여 호출을 하여 얻은 `TypeError`에 대하여 생각해 보자.
*대부분의 사람들*은 코드가 실행되면서 에러를 발견하게 되는 것을 좋아하지 않는다. - 이러한 에러들은 버그로 간주됟다.
우리가 새로운 코드를 쓸때, 우리는 새로운 버그를 만들지 않으려고 최선을 다한다.

우리가 단지 소량의 코드를 추가하는 경우, 파일을 저장하고, 우리의 앱을 갱신하고, 그러면 즉시 우리는 에러를 보게된다. 우리는 즉시 문제가 무언지 알수 있을 것이다; 그러나 항상 이러한 경우만 있는 것이 아니다.
우리는 추가한 기능을 충분히 테스트 하지 않았을 수도 있고, 따라서 잠재적 에러를 발견하지 못한채로 테스트 실행을 마칠 수 있다.
또는 우리가 매우 운이 좋아서 이 에러를 발견했다면, 이 에러를 처리하고자 대량의 코드 리팩토링과 많은 양의 다른 코드를 추가로 작성해야 할지도 모른다.

이상적으로는, 우리의 코드가 실행되기 전에 이러한 버그를 발견하고 도와줄 수 있는 도구가 있다면 좋을 것이다.
타입스크립트의 정적 타입체커가 바로 이러한 도구이다.
*정적 타입 시스템*은 우리의 값들이 실행될 때의 모양과 행동을 기술한다.
타입스크립트가 갖고 있는 타입 검사기는 그러한 타입 정보를 이용하여 실행시 문제가 될수 있는 것들을 컴파일 타임에 미리 말해 준다.

```ts
let foo = "hello!";

foo();
```

위 문장은 타입스크립트가 코드가 실행되기 전에 에러가 있음을 우리에게 알려준다.

## Non-exception Failures

지금까지 우리는 런타임 에러에 대하여 다루어 보았다 - 자바스크립트 런타임이 두손 들어버리고 무언가 의미가 맞지 않는다고 생각하는 경우들이다.
이러한 경우들은 [the ECMAScript specification](https://tc39.github.io/ecma262/) 이 언어가 무언가 예상치 못한 경우에 봉착하면 어떻게 행동해야 할지를 명확히 기술 함으로써 나타나는 것들이다.

예를 들어, 그 규격은 호출할 수 없는 어떤 것을 호출하려고 하는 경우 에러를 던지라고 말하고 있다.
이러한 것은 아마도 "명백한 행위" 처럼 보이는데, 그러나 행뮈만이 아니라 객체에 존재하지 않는 프로퍼티에 접근하려 하는 경우에도 에러를 던지는 것을 당신은 짐작할 것이다.
그러나 이경우에는 에러를 던지는 대신, 자바스크립트는 다른 행동을 하며 `undefined` 값을 가지고 리턴할 것이다:

```js
let foo = {
    name: "Daniel",
    age: 26,
};

foo.location; // returns undefined
```

궁극적으로, 정적 타입 시스템은 자바스크립트의 경우 "적절"하며 실행시에만 에러가 나는 경우라 하더라도, 컴파일 타입에 코드에 에러가 있음을 체크하도록 한다.
타입스크립트에서는 다음의 코드는 `location`이 정의 되어 있지 않음을 출력한다:

```ts
let foo = {
    name: "Daniel",
    age: 26,
};

foo.location; // returns undefined
```

그러나 때로는 이것은 당신의 표현력에 트레이드-오프가 있음을 암시하며, 그 의도는 우리의 프로그램에 문법적인 버그가 있음을 잡아내려는 것이다.
타입스크립트는 *수많은* 문법적 버그를 잡아낸다.
예를 들어, 오타들,

```ts
let someString = "Hello World!";

// 얼마나 빨리 오타를 찾아내었나요?
someString.toLocaleLowercase();
someString.toLocalLowerCase();

// 우리는 이렇게 치려고 했을 겁니다...
someString.toLocaleLowerCase();
```

호출되지 않는 함수,

```ts
function flipCoin() {
    return Math.random < 0.5;
}
```

또는 기본적 로직 에러.

```ts
const value = Math.random() < 0.5 ? "a" : "b";
if (value !== "a") {
    // ...
}
else if (value === "b") {
    // 제어가 여길 오지 않습니다.
}
```

## Types for Tooling

<!-- TODO: this section's title sucks -->

타입스크립트는 우리가 코드에 버그를 만들면 그것을 잡아 냅니다.
그것은 아주 훌륭합니다. 그라나 타입스크립트는 *또한* 그러한 실수를 처음부터 방지하도록 해줍니다.

타입체커는 우리가 변수의 프로퍼티에 옳게 접근하는지 검사할 수 있는 정보를 가지고 있습니다.
타입체커가 한번 이러한 정보를 가지면, 이제는 당신이 프로퍼티를 사용하려고 할때 *제안*하는 능력을 가질수 있습니다.

이것이 의미하는 것은 타입스크립트는 코드를 에디팅 할때도 잇점을 가집니다. 타입체커의 코어는 에러메시지를 제공할 수도 있고, 에디터에서 코드완성도 지원해 줄수 있습니다.

<!-- TODO: insert GIF of completions here -->

타입스크립트는 도구화를 진정으로 가져옵니다. 그리고 그서은 코드완성과 에러출력을 넘어섭니다.
에디터는 "quick fixes" 라는 기능을 통하여 에러를 자동으로 수정하는 것을 지원하고, 코드의 리팩토링을 지원하고, 코드내부의 유용한 탐헝 기능을 제공하여 변수의 선언부로 이동하거나, 주어진 변수의 모든 참조를 찾기도 합니다.
이러한 모든 기능들은 모두 타입체케에 기빈해야 가능하면 또한 완벽한 크로스 플랫폼을 지원합니다. 따라서 [단신의 선호하는 에디터가 타입스크립트를 지원하는가](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support)를 알수 있습니다.

<!-- TODO: validate that link -->

## `tsc`, the TypeScript compiler

지금까지 타입체킹에 대하여 이야기 했는데, 우리는 아직 타입체커를 사용해보지 않았습니다.
`tsc`라는 타입스크립트 컴파일러와 친해져 보도옥 하죠.
먼저, npm 을 통해서 설치할 수 있습니다.

```sh
npm install -g typescript
```

> 이 명령은 타입스크립트 컴파일러 `tsc` 를 글로벌 하게 설치합니다.
> 만약 당신이 로컬 `node_modules` 팩키지로 사용하기를 선호한다면 당신은 `npx` 또는 비슷한 도구를 사용할 수도 있습니다.

이제 빈 폴더를 하나 만들고 우리의 첫번째 타입스크립트 프로그램 `hello.ts`을 작성해 봅시다:

```ts
// 세상에 인사.
console.log("Hello world!");
```

이 코드에는 아무런 화려한 장식이 없음을 알아 주세요; 이 "hello world" 프로그램은 자바스크립트의 것과 동일한 것처럼 보입니다.
이제 `tsc`를 사용하여 타입 체크를 해 봅시다.

```sh
tsc hello.ts
```

Tada!

잠시만요, "tada" 가 정학히 *무엇* 인가요?
우리는 `tsc` 를 실행했고 아무일도 일어나지 않았습니다!
글쌔요, 여기에는 타입에러가 없었고, 그래서 아무것도 리포트 할게 없었고, 그래서 콘솔에 아무것도 안 나온 것입니다.

그러나 다시 체크해보세요 - 우리는 콘솔 출력대신 *파일*하나를 얻었습니다.
이 파일은 현재 디렉토리에 있으며 그 이름은 `hello.js` 이다.
이것이 `hello.ts` 파일을 *컴파일* 또는 *변환* 하여 순수한 자바스크립트 파일로 만든 것이다.
이 파일의 내용을 보면, 타입스크립트는 다음의 내용을 산출해낸 것을 알수 있다:

```js
// 세상에 인사.
console.log("Hello world!");
```

이 경우, 타입스크립트가 변환한거는 거의 없고, 따라서 타입스크립트 소스와 산출된 자바스크립트가 동일하게 보인다.
컴파일러는 깨끗한 읽기 가능한 코드를 산출하려하며 마치 사람이 쓴 것처럼 보이기도 한다.
물론 이러한 시도가 항상 쉬운 것은 아니며, 타입스크립트는 들여쓰기를 일관성 있게 하며, 코드가 여러라인에 걸치는 경우 세심하게 다루며 코멘트를 적절한 위치에 배치하려 한다.

우리가 타입체킹 에러를 만든건 어떻게 될까?
`hello.ts`를 다시 작성해 보자:

```ts
// @noImplicitAny: false
// This is an industrial-grade general-purpose greeter function:
function greet(person, date) {
    console.log(`Hello ${person}, today is ${date}!`);
}

greet("Brendan");
```

`tsc hello.ts` 를 다시 실행하면 다음과 같은 에러 출력을 얻게 된다!

```txt
Expected 2 arguments, but got 1.
```

타입스크립트는 우리가 `greet` 험수에 아규먼트 하나를 빼먹었다고 말해준다.
지금까지 표준 자바스크립트만을 써서 작성했지만 타입체킹은 우리 코드의 문제점을 찾아내었다.

### Emitting with Errors

당신이 눈치채지 못하는 한가지는 방금 예제에서 우리의 `hello.js`는 다시 변화했다는 것이다.
이 파일을 다시 열어 본다면 우리는 그 내용이 우리의 인풋 ts파일과 기본적으로 동일하다는 것을 볼 수 있을 것이다.
이 사실은 약간 놀라울 수도 있는데 왜냐면 `tsc`는 에러 리포트를 했기 때문이다. 그러나 이것은 타입스크립트 코어의 기본에 기반한 것이고 시간이 지날수록 당신은 타입스크립트에 대해서 더 잘 알게 될 것이다.

처음으로 다시 돌아가서, 타입 체킹은 실행가능한 프로그램의 종류를 제한한다. 따라서 타입체커가 수용가능한 것들의 종류에 관한 트레이드-오프가 발생한다.
대부분의 경우 이 것은 문제가 안된다, 그러나 이러한 타입 체킹이 방해물이 되는 경우가 존재한다.
예를 들어, 당신이 자바스크립트 파일을 타입스크립트로 변환하는 작업을 하고 있고, 이러한 변경이 타입체킹 에러를 만들어 내는 경우가 있다.
결과적으로 당신은 코드를 타입체커가 요구하는 대로 수정해서 이 문제를 해결하겠지만, 원래의 자바스크립트 코드는 이미 잘 동작하던 것이었다.
왜 타입스크립트로 변환된 코드가 실행을 못하게 되도록 놔둬야 하는가?

따라서 타입스크립트는 방해물이 되어서는 안된다.
물론, 시간이 지나면서, 당신은 실수에 대해서 더욱 수비적인 자세가 될수 있다. 그리고 타입스크립트의 타입 검사를 더 엄격하게 할 수도 있다.
만약 그런 경우라면 당신은 `--noEmitOnError` 컴파일러 옵션을 사용할 수 있다.
`hello.ts` 수정하고 `tsc`를 이 옵션으로 실행해 보자:

```sh
tsc --noEmitOnError hello.ts
```

당신은 `hello.js`가 변경되지 않음을 알아낼 수 있다.

## Explicit Types

지금까지, 우리는 타입스크립트에게 `person` 또는 `date`가 무엇인지 말하지 않았다.
우리의 코드를 조금 바꾸어서 `person`이 `string` 이고, `date` 가 `Date` 객체임을 기술해 주자.
우리는 또한 `toDateString()` 메소드를 `date`에 사용할 것이다.

```ts
function greet(person: string, date: Date) {
    console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
```

우리가 한 것은 *타입 명기* 를 `person` 과 `date` 에게 주어서 그들의 타입이 무엇 인지 기술하여 `greet` 함수가 어떻게 호출되어야 하는지 명확히 한 것이다.
이러한 함수 시그니쳐를 "`greet` 함수는 `string` 타입의 `person` 과 `Date` 타입의 `date` 를 받는다" 라고 읽는다.

이러한 타입 명기로 타입스크립트는 다른 경우로 이 함수를 호출할 경우 올바로 동작하지 않는다는 것을 우리에게 알려 준다.
예를 들어...

```ts
function greet(person: string, date: Date) {
    console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", Date());
```

어?
타입스크립트는 두번째 아규먼트에 대해서 에러를 리포트 한다, 근데 왜?

놀랍게도, 자바스크립트에서 `Date()`의 호출은 `string`을 반환한다.
반면에 `new Date()`를 사용하여 `Date` 객체를 만드는 경우 우리가 원하는 결과를 가져온다.

어찌됐든, 우리는 재빨리 에러를 수정하였다:

```ts
function greet(person: string, date: Date) {
    console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

greet("Maddison", new Date());
                  ^^^^^^^^^^
```

우리가 항상 타입명시를 사용하지는 않는다는 점을 명심하라.
많은 경우에, 타입스크립트는 타입을 *추정*함으로써 우리가 타입 명시를 빼먹어도 타입을 알 수 있다.

```ts
let foo = "hello there!";
    ^?
```

우리가 `foo`의 타입이 `string` 이라고 명시하지 않아도 이 타입은 추정될 수 있다.
이 것은 하나의 특성이며, 타입시스템이 타입 추정이 가능한 경우 굳이 타입을 명시하지 않는 것이 좋다.

## Erased Types

`tsc`를 사용하여 컴파일 했을 때 무슨일이 벌어지는지 살펴보자:

```js
function greet(person, date) {
    console.log("Hello " + person + ", today is " + date.toDateString() + "!");
}
greet("Maddison", new Date());
```

두가지 사실을 유념하자:

1. `person` 과 `date` 파라메터는 더이상 타입 명시를 갖지 않는다.
2. "template string"(`` ` ``문자를 사용한 문자열) 은 (`+`)를 사용하여 일반적 문자열로 변환 되었다.

두번째 것은 나중으로 미루고, 지금은 첫번째 것에 집중해보자.
타입 명시는 자바스크립트의 것이 아니다, 따라서 어떠한 브라우저나 런타임이 타입스크립트를 수정없이 실행할 수는 없다.(***최근에 타입스크립트를 변환없이 실행하는 엔진이 Rust언어로 작성되어 릴리즈 되었다.)
이 이유 때문에 타입스크립트는 자바스크립트로 변환되어 실행되는 방식을 사용한다.
대부분의 타입스크립트에 특징적인 요소들은 삭제된다 - 우리의 타입 명시도 완전히 삭제되어 자바스크립트로 변환 되었다.

> **Remember**: 타입 명시는 컴파일 타임의 에러를 잡아내기 위함이다. 이것은 프로그램의 행동에 변화를 주지 않는다.

## Downleveling

다른 하나의 변화는 template string 아 변경되었다는 것이다. template string은 

```js
`Hello ${person}, today is ${date.toDateString()}!`
```

로부다

```js
"Hello " + person + ", today is " + date.toDateString() + "!"
```

로 바뀌었다.
왜 이런변환이 발생했을까?

Template strings는 ECMAScript 2015(a.k.a. ECMAScript 6, ES2015, ES6, etc) 라고 불리우는 버젼의 특성이다.
타입스크립트는 신규버젼의 자바스크립트부터 오래된 버젼까지 즉, ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5) 까지 폭넓게 코드를 변환 할 능력이 있다.
이렇듯, 높은 버젼으로부터 낮은 버젼으로 옮겨가는 일련의 과정을 *downleveling*이라 부른다.

기본 세팅으로, 타입스크립트는 ES3을 타겟으로한 코드를 생성한다. 이 ES3은 극단적으로 오래된 버젼이다.
`--target`을 사용해서 우리는 좀더 신규 버젼의 코드를 생성할 수 있다.
`--target es2015` 옵션은 런타임 환경이 ECMAScript 2015를 지원하는 경우 사용할 수 있다.
`tsc --target es2015 input.ts`를 사용하면 다음의 출력을 얻을 수 있다:

```js
function greet(person, date) {
    console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}
greet("Maddison", new Date());
```

> 기본 타겟이 ES3이지만, 대다수의 현대 브라우저는 ES5를 지원한다.
> 대다수의 개발자들은 따라서 안전하게 ES5 를 타켓으로 해서 개발을 할 수 있다 - 특별히 오래된 브라우저와의 호환성이 중요한 경우가 아니라면.

## Strictness

서로 다른 사용자는 타입체커에서 서로 다른 것을 원한다.
어떤 사람들은 좀더 완화된 검사를 해서 프로그램의 특정 부분만의 적정성 검사를 원한다.
이것은 기본적 타입스크립트 사용자 경험이다 - 타입은 옵션이고, 타입추정이 대부분의 허술한 타입의 경우이고, 잠재적인 `null`/`undefined` 값 검사를 하지 않는 것이다.
대부분의 사람들은 `tsc` 가 에러를 만나도 코드를 출력하는 것을 좋아한다. 이러한 디폴트 설정은 타입스크립트가 방해물이 되지 않게 하기 위한 것이다.
만약 기존의 자바스크립트를 타입스크립트로 변환하는 작업을 한다면 이러한 것들은 첫번째 요구사항이 될 것이다.

반면에, 많은 사용자들은 타입스크립트가 할 수 있는 최대한 적정성 검사를 하기를 원한다. 이러한 이유로 엄격함 옵션이 또한 생겨 났다.
이러한 엄격성 세팅은 정적 타입 체킹을 단순한 온오프 스위치에서 세밀히 조정할 수 있는 다이얼로 바꾸어 놓았다.
다이얼을 더 올리면, 타입 체킹은 더 엄격해 진다.
이것은 몇가지 추가적인 일을 요구하는데, 일반적으로 말해서 이러한 작업은 가치가 있으며 장기적으로 보았을 때 좀더 통찰력이 있는 타입체크와 정밀한 도구의 사용법이 될 것이다.
가능하다면, 새로운 기반 코드의 작성은 이러한 엄격한 체크를 모두 하는 것이 좋다.

타입스크립트는 몇가지 타입체크를 위한 옹오프 할수 있는 엄격함 플래그를 제공한다.
또한 우리의 모든 예제는 따로 기술하지 않는 경우 이러한 스위치를 모두 켠 상태이다.
`--strict` 플래그는 이러한 스위치를 모두 한꺼번에 켜고 끌수 있는 것이다. 그러나 우리는 개별적으로 각각의 스위치를 온 오프 할 수 있다.
두개의 가장 영향이 크고 당신이 알아야 할 중요한 플래그는 `noImplicitAny` 와 `strictNullChecks` 이다.

### `noImplicitAny`

몇몇 장소에서 타입스크립트는 타입 추정에 실패하고 가장 허술한 타입인 `any`로 추정한다는 것을 기억하라.
이것은 일어날 수 있는 최악의 상황은 아니다. - 결국 `any` 로 물러나는 것은 단지 순수 자바스크립트 경험이다.

하지만, `any`의 사용은 때때로 타입스크립트를 사용하는 목적을 처음부터 물리치는 행위이다.
프로그램이 타입화 될수록, 적정성 판단과 버그의 자동화 발견은 머 잘 이루어 진다. 이것의 의미는 당신의 코드는 더 적은 버그를 가지는 것이다.
`noImplicitAny` 플래그를 켜면 타입 추정에서 `any`로 되는 경우 에러를 출력하도록 해준다.

### `strictNullChecks`

기본적으로, `null` 과 `undefined` 는 어떤 타입에도 대입할 수 있다.
이것은 어떤 코드를 더 쉽게 작성할 수 있개 해주는데, 만약 `null` 과 `undefined`룰 적절히 처리하는 코드가 빠진 경우 수많은 버그를 양산한다 - 이것은 다른 언어에서도 마찬가지다.
`strictNullChecks` 플래그는 `null` 과 `undefined` 가 명시적으로 처리되었는지를 검사해서 우리가 잊고 처리하지 않은 경우를 잡아낸다. 이것은 우리를 좀더 안심 하고 코딩하게 해준다.
